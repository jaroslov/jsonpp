= Begin-End Library =

The Begin-End library adds support for non-member access to the `begin` and `end` functions, and also adds support for the `sequence` function. Default support exists for containers which satisfy the _de facto_ container concept used by the STL.

All of the functionality of the Begin-End library is within the namespace `bel` in the file "begin-end.hpp". An example program is [http://code.google.com/p/jsonpp/source/browse/trunk/test_bel.cpp here].

The following identifiers will be used:
  * `K` : `container` _some container type_
  * `C` : `container` _some container value_
  * `T`, `U` : `tag` _some tag type_
  * `t`, `u` : `tag` _some tag value_

|| *Expression* || *Meaning* || *Notes * ||
|| `iterator<K,T>::type` || the type of iterator for a container of type _K_ with tag _T_ || ||
|| `begin(C)` || returns the start of the sequence || implemented as `begin(C,mutable__)`; calls `C.begin()` ||
|| `begin(C,t)` || returns the start of the sequence || calls `C.begin()` ||
|| `end(C)` || returns the end of the sequence || implemented as `end(C,mutable__)`; calls `C.end()` ||
|| `end(C,t)` || returns the start of the sequence || calls `C.end()` ||
|| `sequence(C)` || returns a pair of iterators to the start and end of the sequence || implemented as `sequence(C,mutable__)`; calls `begin(C)` and `end(C)` ||
|| `sequence(C,t)` || returns a pair of iterators to the start and end of the sequence || calls `begin(C,t)` and `end(C,t)` ||

Because the `begin`, `end`, and `sequence` functions are not members, the set of kinds of iterators that are selected from a given container type is open. This means that a single container can provide multiple different types of iterators, while leaving the determination of the selection of the iterator kind up to the user. For example:

{{{
template <typename Container, typename IterKind>
void neat_function (..., Container ... C, ..., IterKind ... iterK, ...) {
  typedef typename iterator<Container,IterKind>::type iterK_type;
  iterK_type itr, ind;
  boost::tie(itr,ind) = bel::sequence(C,iterK);
}
}}}

Note that the user of the function can select the iterator kind needed within the function. (This assumes that the different iterators satisfy the same iterator category, with possibly variant semantic meanings.)

The Begin-End library provides a number of built-in tags. Built-in tags have a _type_ and a _name_; the _name_ represents a statically allocated (constant) instance of the tag of the same _type_.

|| *Tag Type* || *Tag Name* || *Meaning* ||
|| `mutable__` || `mutable_` || the value referenced by the iterator can be mutated through the iterator ||
|| `const__` || `const_` || the value referenced is roughly `const` ||
|| `reverse__` || `reverse_` || the sequence is reversed (and `mutable__`) ||
|| `const_reverse__` || `const_reverse_` || the sequence is reversed (and `const__`) ||
|| `trivial__` || `trivial_` || a trivial category iterator ||
|| `input__` || `input_` || an input category iterator ||
|| `output__` || `output_` || an output category iterator ||
|| `forward__` || `forward_` || a forward category iterator ||
|| `bidirectional__` || `bidirectional_` || a bidirectional category iterator ||
|| `random_access__` || `random_access_` || a random access category iterator ||

For convenience, the Begin-End library also provides functions for getting the `begin`, `end` and `sequence` of `stream`s; the functionality is provisional based upon your compiler's support for default function template parameters.

Extending support for new kinds of iterators (tags) or specific acquisition of an iterator category or kind from a container simply requires that the `iterator` metatemplate function be specialized for either your tag, your container, or both. In addition, you may need to write overloads specialized for your tag for the `begin` and `end` functions. Since the `sequence` function relies on the `begin` and `end` functions, it is not necessary to override this function, unless it is more efficient to do so.