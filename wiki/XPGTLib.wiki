#summary XPath Generic Template Library

= XPGTL =

Import from VPath Lib.

A code example is available [http://code.google.com/p/jsonpp/source/browse/trunk/test_vpath.cpp here].

The XPGTL relies on the [BeginEndLibrary BEL] and the [RDSTL RDSTL] for functionality. Specifically, it adds a few XPath-related concepts to the RDSTL. It also defines a parameterized [http://code.google.com/p/jsonpp/source/browse/trunk/xpgtl/path.hpp path] object to store an XPath, and a parser for a subset of the XPath standard. The XPGTL also defines a set of _query_ functions for performing queries of data-structures that satisfy at least the `Children` and `Tag` concepts of the RDSTL.

A brief example of usage follows:

{{{
// using namespace xpgtl;
R r; // R is some recursive data-structure
std::set<std::string const*> result
  = query("//string", r, as<std::string>());
}}}

A query is performed by calling the XPGTL function `query` with a string representing an XPath statement, and an instance of a data-structure satisfying the proper concepts. In this case, an `as` statement is used to filter the result-set to be only `std::string` and to return that set.

_ *Note* because the type of `result_set` uses the `std::set`, all types within the type `reference_union` *must* have the strict-less-than operator defined on them (`operator <`)._

A _root_ recursive data-structure (in the code above, the instance `r`) must satisfy at least one `DiscriminatedUnion` carrier. For non-trivial functionality the children of the recursive data-structure should satisfy the RDSTL `Children` concept, where appropriate. The XPGTL emulates "parent" support when the recursive data-structure does not support it, however, since it cannot guarantee to find the root element, XPath statements using the "parent", "ancestor", or "ancestor-or-self" axes may not return correct results according to the standard. (This is because the standard assumes that the root is always available from any node.)

== XPath Concepts ==

The XPGTL defines one additional concept, in addition to a class of "tags" for compatibility with the C++ compatibility layer of the RDSTL.

For compatibility with the [BEL BEL] and the C++ layer, the parameterized tag `xpath` is provided within the `xpgtl` namespace. The default is to use the "root" recursive data-structure type as the instantiation of the parameter of the `xpath` tag. Thus, within this code:

{{{
R r;
... = query("//string", r);
}}}

The tag is instantiated (internally) as `xpath<R>`. This means that specializations of template metafunctions should either be parameterized on `X` (the recursive data-structure), or only the appropriate rooted data-structure be used. Eventually, a mechanism will be used to specify the instantiation, but this is currently not supported.

=== Attributes Concept ===

The `Attributes` concept has two carrier types, `R` and `Tag`. (See the [RDSTL RDSTL] for more information about `R` and `Tag`.) The following expressions must hold:

|| *Expression* || *Meaning* || *Note* ||
|| `attribute_union` || a discriminated union of attributes || could be trivial ||
|| `attribute(R, string, Tag)` || acquires the attribute associated with the string `string` || could be a `wstring` or a `string`, etc.; returns `attribute_union` ||

The concept is defined like this:

{{{
concept Attributes<typename R, typename Tag> {
  Regular attribute_union;
  attribute_union attribute (R, std::string, Tag);
}
}}}

Unicode support is provided by injection literal-forms of unicode points, i.e., "\uXXXX" or "\UXXXXXXXX", for hexadecimal characters "X". For C++ compatibility the metafunction `has_attributes<R,Tag>` specifies whether the type `T` has attributes. 