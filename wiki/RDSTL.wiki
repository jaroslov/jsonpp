#summary Concepts for the RDSTL

= Recursive Data-Structure Template Library =

The Recursive Data-Structure Template Library (RDSTL) defines a hierarchy of concepts for types which are _recursive_. By recursive, it is meant types that form trees over types. A simple example the usual tree-type over nodes and leaves.

First, let there exist a _discriminated union_ concept.

  * `U` : the type of a discriminated union
  * `u` : an instance of type `U`
  * `T`,,0,,, `T`,,1,,, ..., `T`,,k,, : the closed set of associated types of the discriminated union
  * `t`,,0,,, `t`,,1,,, ..., `t`,,k,, : instances of the above types
  * `V` : the type of a visitor for the type `U`
  * `v` : an instance of type `V`

== Discriminated Union Concept ==

A discriminated union must satisfy at least one modeling relationship to the discriminated union concept. The discriminated union concept has two carrier types, `U`, and `V`. The following expressions must hold:

|| *Expression* || *Meaning* || *Note* ||
|| `u = t`,,i,, || assignment || for all 0<=i<=k ||
|| `visit(v, u)` || visitation || see below ||

Internally, the visitor must satisfy the `Boost.StaticVisitor` concept. A `StaticVisitor` must have the following expressions:

=== Visitor Concept ===

|| *Expression* || *Meaning* || *Note* ||
|| `result_type` || the associated resultant type || _see below_ ||
|| `v.operator () (const T`,,i,,`&) const` || visitor _call_ operation || the return type is `result_type` ||

The discriminated union concept captures both the union and the visitor for the union.

{{{
concept DiscriminatedUnion<typename U, typename V> {
  requires Visitor<V>; // see below
  Regular result_type = V::result_type;
  U& operator = (U&, V v);
  result_type visit (V, U);
  result_type V::operator () (U) const;
}
}}}

== Recursive Data-Structure Concepts ==

There are a number of concepts defined in the RDSTL. These concepts are mostly orthogonal. Some of the concepts have meta-template functions defined for them so that they work without support of a concepts-system.

  * `R` : some recursive data-structure type
  * `r` : an instance of `R`
  * `Tag` : some tag associated with a modeling of `R` as a recursive data-structure
  * `tag` : some instance of `Tag`

== Reference Union ==

Any data type that supports _any_ of the following concepts must also satisfy the concept `ReferenceUnion`. The `ReferenceUnion` concept has two carrier types, `R` and `Tag`. It has the following valid expressions.

  * `Q` : some type that is a `ReferenceUnion`
  * `q` : some instance of `Q`
  * `T` : some type within `R`
  * `t` : an instance of `T`

|| *Expression* || *Meaning* || *Note* ||
|| `q = &t;` || assignment from reference to type in `R` || must support at least all the types in `R` ||

The concept follows; it is modified to carry a third type, because `ReferenceUnion` refines the `DiscriminatedUnion` type.

{{{
concept ReferenceUnion<typename Q, typename T, typename Tag> {
  Q& operator = (Q&, T const*);
}
}}}

== Tag Concept ==

The `Tag` concept has two carrier types, `R` and `Tag`.

|| *Expression* || *Meaning* || *Note* ||
|| `type` || the associated label (tag) type || available by: `template <typename T, typename Tag> struct has_tag;` sp. `has_tag<R,Tag>::type` ||
|| `tag(R, tag)` || acquires the tag for type/instance `R` || returns `type` ||

The concept is this:

{{{
concept Tag<typename R, typename Tag> {
  Regular type;
  type tag (R, Tag);
}
}}}

For C++ compatibility, membership is specified by specialization of the `has_tag<R, Tag>` metafunction.

== Children Concept ==

The `Children` concept has two carrier types, `R` and `Tag`.

|| *Expression* || *Meaning* || *Note* ||
|| `value_union` || a discriminated union of the closed set oftypes for `R` under `Tag` || see discriminated union above; implicitly available; also `value_union<R,Tag>` ||
|| `bel::iterator<R,Tag>::type` || the type of the iterators || `std::pair<iterator,iterator>` of them; available from `bel::iterator<R,Tag>::type ||
|| `children(R, tag)` || returns a sequence of children || see `bel::sequence` ||

The `Children` concept provides a method of accessing the children of a recursive data-structure.

{{{
concept Children<typename R, typename Tag> {
  Regular value_union; // no way to specify variadic concepts
    // in ConceptC++; the requirement is place
    // elsewhere for DiscriminatedUion
  ForwardIterator iterator;
  std::pair<iterator,iterator> children (R, Tag);
}
}}}

For C++ compatibility, membership is specified by specialization of the `has_children<R, Tag>` metafunction. The metafunction `has_value_union<R,Tag>` is specialized if the struct `value_union<R,Tag>` is specialized. The expression `value_union<R,Tag>::type` returns the value-union. The `value_union` is not required, because not all recursive data-structures are defined in terms of discriminated unions.

== Parent Concept ==

The `Parent` concept has two carrier types, `R` and `Tag`. It refines the `Children` concept.

|| *Expression* || *Meaning* || *Note* ||
|| `parent_type` || the type of the parent || usually a reference or proxy ||
|| `parent(R, tag)` || returns `parent_type` || usually a reference or proxy  ||

The concept is this:

{{{
concept Parent<typename R, typename Tag> : Children<R,Tag> {
  Regular parent_type;
  parent_type const& parent (R, Tag);
}
}}}

For C++ compatibility, membership is specified by specialization of the `knows_parent<R, Tag>` metafunction.

== Proxy Concept ==

The `Proxy` concept is an orthogonal concept with two carrier types, `R` and `Tag`. Some recursive hierarchies require the construction of ephemeral types and proxy types. These types should be marked so that references are not formed to them.

The concept is this:

{{{
concept Proxy<typename R, typename Tag> {}
}}}

For C++ compatibility, membership is specified by specialization of the `is_proxy<R, Tag>` metafunction.